---
layout: single
title: TIL) AOP와 AspectJ는 세탁기로 비유했다.
categories: TIL
tag: [Today I Learned]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
search: true
sidebar:
    nav: "counts"
typora-root-url: ../
---

## 📌 2025-03-09 TIL

## 1. 오늘의 학습 주제
- Spring AOP와 AspectJ를 비교해보자

## 2. 학습 내용

두 기술 모두 관심사 분리를 위해 제공하는 기술입니다.

애플리케이션에서 하나의 서비스에서 필요한게 아니라 모든 서비스에 필요한게 있습니다.

예를 들면 요즘 메장에 들어가면 주문을 위해 필요한 키오스크가 있습니다.



주문을 할 때(서비스 계층)에서 주문 직전에 어떤 음식 목록이 있는지 보여주려고 키오스크를 사용합니다.

결제를 할 때도 키오스크를 사용하게 됩니다.



실제 주문을 하는 서비스를 제외하고 그 외에는 전반적인 모든 음식점에서 사용하려고 하는 관심사입니다.

하지만 실제 주문을 하는 것과는 다른 관심사이지만 비즈니스 로직에 빠질 수는 없습니다.



객체지향 프로그래밍에서 다른 관심사가 하나의 메서드나 클래스에 포함이 된다면 유지보수와 역할에 의존하여 확장하기에는 어려움이 있습니다. 이것을 횡단 관심사라고 말하며 이 관심사를 분리하기 위해 두 가지 기술을 고려할 수 있다는 것을 알았습니다.



### 동적 위빙과 정적 위빙

동적 위빙과 정적 위빙의 방식은 세탁기로 비유할 수 있습니다.

동적 위빙은 세탁기(원본 객체) 위에 코인세탁소 목적으로 겉에 추가적인 기능을 넣은 것을 말합니다.

원본 객체는 건들지 않고 외부에 코인 세탁소 목적으로 자물쇠를 달고 동전을 넣을 수 있도록 만드는 것이죠

그래서 동작방식도 런타임에 관심사 로직이 들어갑니다.



정적위빙은 세탁기(원본 객체)를 세탁기 수리 기사분을 불러서 기존에 없던 기능인 세탁기가 돌아갈 때마다 노래가 나오도록 추가하는 것과 같습니다.

컴파일된 파일(원본.class)을 수리기사(AspectJ)가 수정하여 원본(노래기능이첨가된).class 파일로 변경합니다.

그래서 동작방식도 컴파일 시점에 관심사 코드가 들어갑니다.



### 트레이드 오프

프록시 기반은 상속이나 구현을 기반으로 동작하기 때문에 메서드 기반입니다.

컴파일 기반은 자바 바이트 코드 기반으로 동작하기에 모든 곳에 관심사 코드를 넣을 수 있습니다.



대부분의 서비스에서는 컴파일 기반보다 프록시 기반이 구현이 간단하고 스프링 컨테이너의 동작방식을 그대로 사용할 수 있으므로 학습 곡선이 AspectJ보다 낮습니다.

다만 프록시의 한계인 private, final은 관심사를 넣을 수 없으며 self-invocation 처럼 프록시 내에 메서드를 호출하는 것은 적용이 안됩니다.

그게 아니라 시스템 전반적인 모든 필드나 생성자 프록시의 한계를 모두 해결 가능한 것으로 유연한 것이 AspectJ 입니다.



### 그러면 언제 사용해야할까

스프링 AOP는 스프링 빈을 기반으로 동작하기에 제한이 많습니다.
스프링이 관리하지 않는 톰캣 로직이나 필드, 객체에 대한 관심사 코드를 넣어야할 때에는 AspectJ가 적절합니다.

@서비스, @컴포넌트 처럼 스프링 빈에서 관리하는 것들은 스프링 AOP를 활용하여 관심사를 분리할 수 있으므로

대부분의 서비스에서는 학습 곡선이 더 낮은 Spring AOP를 활용하는 거 같습니다.
