---
layout: single
title: TIL) CAS는 대체 머야
categories: TIL
tag: [Today I Learned]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
search: true
sidebar:
    nav: "counts"
typora-root-url: ../
---

CAS 알고리즘은 매번 학습을 해도 다시 잊게 됩니다.

잊어서 다시 공부하려고 복습을 했습니다.

## 머리속 끄집어내기

CAS 알고리즘을 정리해보겠습니다.

**What**

CAS 알고리즘은 임계 영역을 사용할 때 동기화 문제를 해결하는 방식입니다.

**Why**

Lock 방식의 오버헤드와 성능 저하를 줄이면서 동시성 문제를 해결하기 위해서입니다.

**When**

많은 스레드가 임계영역에 동시에 접근하려고 할 때입니다.

**Where**

운영체제 커널이나 애플리케이션 또는 프로그래밍 수준에서 사용합니다.

**Who**

하드웨어 CPU의 저수준 연산자

**How**

메모리 위치와 예측한 값으로 일치하는 경우 변경할 값으로 수정하며 수정결과를 반환합니다.



**한줄 정리하기**

CAS 알고리즘은 임계 영역을 사용할 때 발생할 수 있는 동시성 문제를 해결하는 방법 중 하나로 Lock 방식의 오버헤드와 성능 저하를 줄일 수 있습니다.
많은 스레드가 동시에 접근할 때 사용하며 운영 체제 커널이나 애플리케이션에서 사용하며 하드웨어 CPU의 저수준 연산자를 통해 메모리 위치와 예측한 값이 일치하는 경우 예상한 값으로 변환되기 때문입니다.



CAS 알고리즘의 문제

+ ABA 문제
+ 스핀락 문제
+ 단일 변수에만 적용 가능



### ABA 문제

**What**

CAS 알고리즘과 같이 수정하려는 데이터의 현재 값과 변경할 값만 가지고 비교하게 되면 발생하는 문제를 말합니다.

> CAS 알고리즘처럼 **값의 동일성만을 기준으로 원자성을 판단**하는 연산에서 값이 A → B → A 로 바뀌었음에도 불구하고 변화가 없다고 판단되는 **동기화 오류**를 말합니다.

**Why**

CAS 알고리즘은 현재 값과 변경할 값만 비교하므로 자료 구조나 그외 상황에서 다른 객체의 값이 수정될 수 있기 때문입니다.

> CAS는 메모리의 중간 변경 이력은 감지하지 못하고, 오직 현재 값을 기대한 값과 같은지만 비교하기 때문에, **값이 바뀌었다가 다시 돌아오는 경우에도 성공 처리될 수 있습니다.**

**When**

> 스레드가 CAS 연산을 하기 전에 **다른 스레드가 해당 메모리를 변경 후 다시 원래 값으로 되돌리는 상황**에서 발생합니다.

**Where**

멀티스레드 환경에서 CAS 오브젝트를 공유하는 경우 발생합니다.

> 멀티스레드 환경에서 **공유 자원에 대한 락프리 구조**(예: Concurrent Stack, Queue)**를 구현할 때 주로 발생합니다.

**Who**

다른 스레드가 발생 시킵니다.  

> CAS를 실행하는 **스레드 자신은 ABA를 감지할 수 없고, 다른 스레드가 값을 바꿨다가 다시 되돌림으로써 ABA 문제를 유발합니다.**

**How**  

ConcurrentStack에서 Top를 PoP하려는 상황

예:

1. 스레드 A가 top == A를 읽음
2. 스레드 B가 A → B → A로 top 값을 변경
3. A가 CAS(expected: A, new: B)를 실행하면, 값은 같기 때문에 성공 → 하지만 **메모리 상태는 이미 변질됨**



#### 정리

ABA는 CAS 알고리즘처럼 메모리 위치와 예측한 값이 일치하면 연산이 가능하도록 하여 그 사이 데이터가 오염되어도 변화가 없다고 판단하는 동기화 오류 문제가 있습니다. 멀티스레드 환경에서 임계 영역에 접근하여 CAS 알고리즘을 수행하기전 데이터가 수정되고 예측한 값으로만 변경된다면 변경 기록은 확인하지 않는 문제가 있습니다.

#### ABA를 다시 정리해보기

처음에는 ABA가 왜 문제인지 인식을 못했습니다.

현재값이 동일하고 그 상태에서 업데이트를 하는 건데 왜 문제가 되는 건지 몰랐어요

단순하게 숫자가 값이 달라지는게 문제가 아닙니다.

처음 읽었을 때 오브젝트 A와 다른 스레드가 연산후 수정된 오브젝트 A가 상태가 같더라고 하더라도 변경이력에 따라 다른 값으로 달라져야할 수 있기 때문입니다.



스레드 A가 특정 오브젝트의 

### 
