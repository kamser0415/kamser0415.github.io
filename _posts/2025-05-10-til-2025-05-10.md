---
layout: single
title: TIL) 파일 디스크립트부터 톰캣까지
categories: TIL
tag: [Today I Learned]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
search: true
sidebar:
    nav: "counts"
typora-root-url: ../

---

이전 TIL에서 서버 과부하에 대한 원인과 현상에 대해서 확인했습니다.

서버 과부하가 발생되는 주 이유는 요청보다 응답이 느리기 때문입니다.

응답이 느린 이유는 디스크 I/O 속도가 클라이언트의 요청 속도보다 매우 매우 매우 ~ 느리기 때문입니다.

하지만 단순히 데이터베이스의 응답이 지연되어 서버 과부하가 오는 것은 아닙니다.



이제는 웹 요청이 과도하게 들어올 경우 웹 서버는 어떻게 동작하는지 확인해보겠습니다.

# 운영체제와 웹서버의 요청 flowchart

![TomcatConnection_RequestHandling_Flow](/images/2025-05-10-til-2025-05-10/TomcatConnection_RequestHandling_Flow.png)

```mermaid
---
title: 톰캣 연결 및 요청 처리 흐름(Tomcat Connection and Request Handling Flow)
---

%% 전체 다이어그램 방향은 위에서 아래 (영역 간 흐름 유도)
flowchart TD

%% External Client
REQ@{ shape: rounded, label: "외부 요청(External Request)" }

%% OS Level - Initial Connection Handling
subgraph "**운영체제 영역**"
    %% 영역 내부 방향은 왼쪽에서 오른쪽
    direction LR
    %% OS Backlog 수용 가능 여부 판단
    DECISION_OS_CAPACITY@{ shape: diam, label: "OS Backlog 수용 가능?" }
    %% 커널 백로그 큐
    OS_BACKLOG@{ shape: das, label: "커널 Backlog 큐(Kernel Backlog Queue)<br>(net.core.somaxconn=15)" }

    DECISION_OS_CAPACITY -- 예(Yes) --> OS_BACKLOG
end

%% Tomcat Level - Application Specific Handling
subgraph "**톰캣 영역**"
    %% 영역 내부 방향은 왼쪽에서 오른쪽
    direction LR

    subgraph "**연결 수락 및 제한**"
        %% 내부 subgraph 방향은 왼쪽에서 오른쪽
        direction LR
        %% 연결 수락
        ACCEPT@{ shape: rect, label: "Tomcat Accept()" }
        %% Max Connections 제한 확인
        DECISION_CONN_LIMIT@{ shape: diam, label: "Max Connections 제한?" }
        ACCEPT --> DECISION_CONN_LIMIT
    end

    subgraph "**요청 큐잉 및 처리**"
        %% 내부 subgraph 방향은 왼쪽에서 오른쪽
        direction LR

        %% 스레드 사용 가능 여부 판단
        DECISION_THREAD_AVAIL@{ shape: diam, label: "스레드 사용 가능?" }

        %% 큐 공간 사용 가능 여부 판단
        DECISION_QUEUE_AVAIL@{ shape: diam, label: "큐 공간 사용 가능?" }

        %% Tomcat 작업 큐 (Accept Queue)
        %% 설정값 추가
        TOMCAT_QUEUE@{ shape: das, label: "Tomcat 작업 큐(Tomcat Accept Queue)<br>(acceptCount=10)" }

        %% Tomcat 워커 스레드
        %% 설정값 추가
        WORKER_THREADS@{ shape: processes, label: "Tomcat 워커 스레드(Tomcat Threads)<br>(maxThreads=3)" }
        %% 요청 처리 중
        PROCESSING@{ shape: rect, label: "요청 처리(Request Processing)" }

        %% Max Connections 제한 통과 후 스레드 사용 가능 여부 판단
        DECISION_CONN_LIMIT -- 미초과(Within Limit) --> DECISION_THREAD_AVAIL

        %% 스레드 사용 가능 --> 바로 워커 스레드로
        %% 요청 범위 명시
        DECISION_THREAD_AVAIL -- 예(Yes)<br>(요청 1~3) --> WORKER_THREADS

        %% 스레드 바쁨 --> 큐 공간 사용 가능 여부 판단
        DECISION_THREAD_AVAIL -- 아니오(No) --> DECISION_QUEUE_AVAIL

        %% 큐 공간 사용 가능 --> 작업 큐로 진입
        %% 요청 범위 명시
        DECISION_QUEUE_AVAIL -- 예(Yes)<br>(요청 4~13) --> TOMCAT_QUEUE

        %% 큐 공간 없음 --> 오류 응답 (큐 가득 참)
        DECISION_QUEUE_AVAIL -- 아니오(No)<br>(큐 가득참) --> RESP_ERROR_Q_FULL

        %% 큐 대기 후 스레드 처리
        TOMCAT_QUEUE --> WORKER_THREADS

        %% 큐 대기 중 타임아웃 발생 --> 오류 응답
        %% SocketTimeout 또는 Queue Timeout (연결 수락 후 처리 시작 전 지연)
        TOMCAT_QUEUE -- 큐 대기<br>Socket Timeout --> RESP_ERROR_Q_TIMEOUT

        WORKER_THREADS --> PROCESSING

        %% 요청 처리 중 타임아웃/지연 발생 --> 오류 응답
        %% SocketTimeout (처리 중 지연)
        PROCESSING -- 처리 중<br>Socket Timeout --> RESP_ERROR_PROC_TIMEOUT

    end
    %% 톰캣 영역 내 내부 subgraph 간 연결 (노드 연결로 흐름 표현)
    %% 명시적인 subgraph 간 링크는 제거 - 노드 연결이 흐름을 나타냄
end

%% Outcomes (External/Final states)
%% Place error states generally to the left and success state to the right for better flow in TD

%% 연결 거절 (OS Backlog Full)
%% 요청 범위 및 발생 원인 명시
CONN_REFUSED@{ shape: doc, label: "연결 거절(Connection Refused)<br>(요청 16 이상)<br>(OS Backlog Full)" }

%% 오류 응답 (Tomcat Accept Queue Full)
%% Queue Full
RESP_ERROR_Q_FULL@{ shape: doc, label: "오류 응답(503)<br>(Tomcat Accept Queue Full)" }

%% 오류 응답 (Queue Timeout)
%% Queue Timeout
RESP_ERROR_Q_TIMEOUT@{ shape: doc, label: "오류 응답(503)<br>(Queue Timeout)" }

%% 오류 응답 (Processing Timeout)
%% Processing Timeout
RESP_ERROR_PROC_TIMEOUT@{ shape: doc, label: "오류 응답(504)<br>(Processing Timeout)" }

%% 오류 응답 (Max Connections Full)
%% Max Connections Full
RESP_ERROR_CONN_LIMIT@{ shape: doc, label: "오류 응답(Connection Error)<br>(Max Connections Full)" }

%% 정상 응답
%% 요청 범위 및 상태 명시
RESP_OK@{ shape: doc, label: "정상 응답(Normal Response)<br>(요청 1~13 처리 완료)" }

%% 전체 흐름 연결 (영역 간/영역과 결과 간)

%% 요청 시작 (OS 진입)
%% 여기서 REQ -> OS_BACKLOG 대신 REQ -> DECISION_OS_CAPACITY 로 연결하여 OS 영역의 시작점으로 연결
REQ --> DECISION_OS_CAPACITY

%% OS Backlog Full 시 연결 거절
DECISION_OS_CAPACITY -- 아니오(No)<br>(요청 16 이상) --> CONN_REFUSED

%% OS에서 Tomcat으로 연결 전달 (accept) - 영역 내 LR 배치 후 영역 간 TD 흐름에 영향을 받도록
OS_BACKLOG --> ACCEPT

%% Max Connections 제한 초과 시 오류 응답 - 영역 내 LR 배치 후 영역 간 TD 흐름에 영향을 받도록
%% Connection Timeout (연결 수락 시도 중 제한) 또는 단순 거절
DECISION_CONN_LIMIT -- 초과(Exceeded)<br>(요청 14~15)<br>(Max Conn Full) --> RESP_ERROR_CONN_LIMIT

%% 처리 완료 시 정상 응답 - 영역 내 LR 배치 후 영역 간 TD 흐름에 영향을 받도록
PROCESSING --> RESP_OK
```



## 정상적인 흐름

**운영체제는 연결을 시도한다.**

클라이언트(브라우저, API) 요청이 들어오면 운영체제는 클라이언트와 연결을 시도하게 됩니다.

클라이언트의 정보와 서버의 정보가 일치하는지 확인하고 TCP/IP 패킷일 경우 3-handshake를 통해 논리적인 연결을 하게 됩니다.



**운영체제는 연결된 후 커널 backlog 큐에 저장한다.**

~~운영체제는 클라이언트와 연결되면 전달받은 정보 패킷을 뜯습니다.~~

~~패킷에 도착지 포트번호를 확인하고 프로세스중 일치하는 포트번호가 있는지 확인합니다.~~

~~일치하는 포트번호가 있다면 해당 포트번호로 `커널 Backlog 큐`에 push합니다.~~

운영체제는 커널에서 포트 매칭 후 연결 객체(socket struct)를 backlog Queue에 push() 합니다.

> backlog Queue
>
> backlog는 **밀린 일, 처리 대기 중인 항목들**을 의미합니다.
>
> + 비즈니스에서 "작업 백로그"는 아직 완료되지 않는 작업 목록
> + 네트워크에서는 "수신은 됐지만 아직 처리되지 않은 연결 요청들"
>
> 그러면 OS에서 backlog queue는 무슨 역할일까?
>
> 클라이언트가 서버에 연결을 요청했지만, 서버 애플리케이션(예: 톰캣)이 아직 그 연결을 accept()`받아들이지` 하지 않았을 때,
>
> **운영체제가 임시로 대기시키는 큐**를 말합니다.
>
> 연결은 들어왔지만, 서버가 아직 받아들이지 않은 상태가 쌓이는 곳입니다.



**톰캣은 소켓을 받아드릴 수 있는지 확인한다.**

`accept()`를 호출하여 소켓을 받아드리기 직전에 현재 연결된 커넥트 수를 확인합니다.

`currentConnectionCount`를 확인합니다.

만약 이 수치가 `maxConnections`이상이면 `accept()`를 보류하거나 거절합니다.

> 커넥션 수를 관리하는 저 변수는 `volatile`로 되어있습니다



~~이때 커널 영역에 있는 소켓 정보를 운영체제가 톰캣 가상 메모리 영역에 복사를 합니다.~~

운영체제는 TCP 연결되면 accept() 하고 그 연결로 데이터를 읽고 쓰고 할 수 있는 FD(파일 디스크립트)를 생성합니다.

예를 들어 fd = 7 로 반환이 되며 이 정보를 가지고 통신할 수 있는 소켓 자원이 됩니다.

톰캣은 이 fd = 7 을 가지고 InputStream, outputStream, close를 하게 됩니다.

> 목욕탕으로 비유합니다
>
> 1. **운영체제(관리자)** 가 네가 들어오자마자 **사물함 키(정수형 FD)** 하나를 줍니다.
> 2. 손님은 그 **번호 하나만 기억**하면 됩니다 — 사물함 위치, 재질, 내부 구조는 몰라도 됩니다.
> 3. 필요한 만큼 **옷을 넣고(쓰기), 꺼내고(읽기)**
> 4. 다 쓰면 **키 반납(close)**
>
> 그래서  여러 요청이 오면 키를 하나씩 발급 받는 구조다.



톰캣은  `Thread Pool`을 조회합니다.

스레드 풀에 워커 스레드를 꺼낼 수 있는지 확인합니다.

스레드 풀은 워커 스레드를 꺼낼 수 없는 경우 대기표를 뽑기 위해 `Accept Queue`를 확인합니다.



큐 공간이 여유가 없는 경우 에러가 발생됩니다. `503 Tomcat Accept Queue Full`

큐 공간에 여유가 있는 경우는 큐 공간에 `push(socket)`을 하게 됩니다.



큐 공간에 들어갔다고 하더라도 대기가 길어지면 오류가 발생되면서 `Queue`에 대기중인 쓰레드들은 하나씩 `TimeOut`으로 요청이 종료됩니다.



큐 공간에서 꺼내옵니다. 워커 스레드 하나를 가져와서 사용자 요청 정보를 처리하게 됩니다.

이때 사용자 요청 처리가 길어지는 경우 `Processing Timeout`으로 예외가 발생하게 됩니다.



그 외에는 정상 응답처리가 됩니다.



## 병목 흐름

병목 흐름은 요청 흐름 순서대로 병목 지점을 추적해보려고 합니다.

TCP → WAS → JDBC → SQL 방식으로 서로 다른 영역을 통신할 때 발생하는 것을 예상할 수 있습니다.

그리고 정책에 따라 요청을 경쟁 상태 또는 준비 큐 같은 큐 구조(`Ready Queue`)에 저장하여 순차적으로 요청을 처리하는 경우도 있습니다.



### 운영체제와 WAS API 병목

```mermaid
---
title: OS 및 톰캣 자원 병목 시나리오 상세 분석(OS and Tomcat Resource Bottleneck Detailed Analysis)
---
%% 다이어그램 방향 설정 (위에서 아래)
flowchart TD

%% 클라이언트 요청 시작 노드
REQ@{ shape: rounded, label: "클라이언트 요청(Client Request)" }

%% 운영체제 영역 서브그래프
subgraph "**운영체제 영역**"
    %% 운영체제 영역 내부 흐름 (단순 판단이므로 위에서 아래)
    %% OS 레벨 FD 한계 여유 확인 분기 노드
    %% 이 지점에서 OS FD 부족 시 시나리오 1 (OS 문제) 및 3 (OS+톰캣 문제) 발생
    DEC_OS_FD@{ shape: diam, label: "OS FD 여유<br>(OS FD Available?)" }
end

%% 톰캣 영역 서브그래프
subgraph "**톰캣 영역**"
    %% 톰캣 영역 내부 흐름 (단순 판단이므로 위에서 아래)
    %% 톰캣 레벨 자원 처리 여유 확인 분기 노드
    %% OS FD 여유 있을 때 이 지점에서 톰캣 자원 부족 시 시나리오 2 (톰캣 문제) 발생
    DEC_TOMCAT_AVAIL@{ shape: diam, label: "톰캣 처리 여유<br>(Tomcat Available?)" }
end

%% 결과 노드들 (doc 도형 사용)

%% 시나리오 1 (OS FD 부족) 및 시나리오 3 (OS+톰캣 부족) 결과
%% OS FD 한계 도달 시, 특히 톰캣도 포화 상태일 때 클라이언트는 Connection refused를 겪기 쉬움
OUT_OS_FAIL@{ shape: doc, label: "연결 거절<br>(Connection refused)<br>(OS FD 한계 초과)" }

%% 시나리오 2 (OS 여유, 톰캣 부족) 결과
OUT_TOMCAT_FAIL@{ shape: doc, label: "503, Timeout<br>(톰캣 자원 부족<br>큐/스레드 병목)" }

%% 시나리오 1 (모두 여유) 결과
OUT_SUCCESS@{ shape: doc, label: "정상 처리<br>(Success)" }

%% 흐름 연결 정의

%% 클라이언트 요청은 먼저 운영체제 영역으로 진입하여 OS FD 여유를 확인
REQ --> DEC_OS_FD

%% OS FD 여유 판단 결과에 따른 분기
%% OS FD 여유 있으면 다음 판단 단계인 톰캣 영역으로 진입
DEC_OS_FD -- 예(Yes) --> DEC_TOMCAT_AVAIL
%% OS FD 부족하면 (시나리오 1, 3) 바로 OS FD 한계 초과 결과로 직행
%% 시나리오 3의 '톰캣도 부족한 상태'는 OS에서 먼저 차단됨으로써 시각화
DEC_OS_FD -- 아니오(No) --> OUT_OS_FAIL

%% 톰캣 처리 여유 판단 결과에 따른 분기
%% 톰캣 여유 있으면 (OS도 여유 있었으므로) 정상 처리 결과로
DEC_TOMCAT_AVAIL -- 예(Yes) --> OUT_SUCCESS
%% 톰캣 부족하면 (OS는 여유 있었으므로) 톰캣 자원 부족 결과로
DEC_TOMCAT_AVAIL -- 아니오(No) --> OUT_TOMCAT_FAIL

%% 주석 개행, 라벨 형식, 도형 매핑 등 모든 규칙을 준수하여 작성되었습니다.
```

![톰캣_운영체제_FD다이어그램](/images/2025-05-10-til-2025-05-10/톰캣_운영체제_FD다이어그램.png)

운영체제와 톰캣 사이에 병목이 일어날 수 있는 구간을 정리해보려고 합니다.

운영체제는 클라이언트의 요청을 확인하면 `TCP 연결`을 하게 됩니다. 논리적인 연결이 성공하게 되면 커널은 클라이언트와 통신할 수 있는 파일 디스크립터(FD)를 만들게 됩니다.

FD는 커널 메모리 영역에 존재하며 운영체제 내 설정으로 최대 갯수를 지정할 수 있습니다.

위 순서도는 결과 처리에 대한 간단한 예제를 보여줍니다.

#### 간단 정리

| 상태 | OS FD | 톰캣 처리 여유 | 결과                                |
| ---- | ----- | -------------- | ----------------------------------- |
| ✅    | ❌     | ✅              | `Too many open files` (accept 실패) |
| ✅    | ✅     | ❌              | `503`, `Timeout` (큐/스레드 병목)   |
| ❌    | ❌     | ❌              | `Connection refused`, `Timeout`     |



### WAS 내 병목



