---
layout: single
title: TIL) RateLimit 감각깨우기(2) 코드 구현
categories: TIL
tag: [Today I Learned]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
search: true
sidebar:
    nav: "counts"
typora-root-url: ../
---

시스템 안정성과 과도한 트레픽을 제어하고 보안 및 사용자의 빠른 응답을 제공하는 것이 백엔드 개발자의 중요한 숙제라고 생각이 들었습니다.

Ratelimit(속도 제한)은 API서버에서 과도한 요청으로 서버를 보호하고 제한된 자원을 공정하게 분배하기 위한 기술이므로 학습하려고 합니다.

## 상황정의

> 서버에 로그인 API가 있다.
>
> 같은 사용자가 1분 안에 **5번 이상 로그인 요청**을 보내면 더 이상 **허용하지 않고 차단**해야 한다.

코드 레벨로 구현해보면서 해당 단계에서 발생할 수 있는 문제를 개선하려고 합니다.



### 1단계

회원 정보를 관리하기 위해서 HashMap 자료구조를 선택하기로 했습니다.

이유는 관리할 회원 데이터가 많지 않으며 해시 충돌이 발생되어 성능 저하가 발생하더라도 테스트 코드 환경에서 O(1)로 동작할 확률이 높기 때문입니다.

그리고 회원이 접속한 시간을 저장하는 시계열 데이터를 관리할 자료구조는 Deque를 선택했습니다.

이유는 `Queue`자료구조를 사용해도 되지만 메서드 명이 더 의미있는 `Deque`를 선택했습니다.



#### 코드

```java
public class LoginRateLimiterV1 implements RateLimiterCustom {

	private long limitTime = 1_000L;

	private final static Map<String, Deque<Long>> rateLimiters = new HashMap<>();

	@Override
	public boolean setLimiterTime(long time) {
		if (time <= 0) {
			return false;
		}
		limitTime = time;
		return true;
	}

	@Override
	public long getLimiterTime() {
		return limitTime;
	}

	@Override
	public boolean isAllowed(String id) {
		Deque<Long> limiterByUserId = rateLimiters.get(id);

		if (limiterByUserId == null) {
			LinkedList<Long> deque = new LinkedList<>();
			deque.addLast(System.currentTimeMillis());
			rateLimiters.put(id, deque);
			return true;
		}

		if (limiterByUserId.size() < 5) {
			limiterByUserId.addLast(System.currentTimeMillis());
			return true;
		}

		Long firstTimeMillis = limiterByUserId.peekFirst();
		Long lastTimeMillis = System.currentTimeMillis();

		if (lastTimeMillis - firstTimeMillis < limitTime) {
			return false;
		}
		limiterByUserId.removeFirst();
		limiterByUserId.addLast(lastTimeMillis);

		return true;
	}

	public int size(String id) {
		return rateLimiters.get(id).size();
	}
}
```

#### 테스트 코드 작성

간단하게 5회, 6회 경계 테스트를 해보려고 합니다.

```java
class LoginRateLimiterV1TestSelf {

	@Test
	@DisplayName("로그인 시도 횟수가 5회일 경우 제한되지 않습니다.")
	void testLoginRateLimiterV1() {
		LoginRateLimiterV1 loginRateLimiterV1 = new LoginRateLimiterV1();
		loginRateLimiterV1.setLimiterTime(1000);

		String userId = "UserId";

		loginRateLimiterV1.isAllowed(userId);
		loginRateLimiterV1.isAllowed(userId);
		loginRateLimiterV1.isAllowed(userId);
		loginRateLimiterV1.isAllowed(userId);

		Assertions.assertThat(loginRateLimiterV1.isAllowed(userId)).isTrue();
	}

	@Test
	@DisplayName("로그인 시도 횟수가 6회일 경우 제한")
	void testLoginRateLimiterV2() {
		LoginRateLimiterV1 loginRateLimiterV1 = new LoginRateLimiterV1();
		loginRateLimiterV1.setLimiterTime(1000);

		String userId = "UserId";

		loginRateLimiterV1.isAllowed(userId);
		loginRateLimiterV1.isAllowed(userId);
		loginRateLimiterV1.isAllowed(userId);
		loginRateLimiterV1.isAllowed(userId);
		loginRateLimiterV1.isAllowed(userId);

		boolean allowed = loginRateLimiterV1.isAllowed(userId);
		Assertions.assertThat(loginRateLimiterV1.size(userId)).isEqualTo(5);
		Assertions.assertThat(allowed).isFalse();
	}

}
```

테스트 결과는 성공입니다.

사실 이 테스트는 함정이 있습니다.

```java
@Test
@DisplayName("처음 생성한 인스턴스이지만 정적 필드를 공유해서 이 테스트가 실패한다.")
void testLoginRateLimiterV3() {
  LoginRateLimiterV1 loginRateLimiterV1 = new LoginRateLimiterV1();

  boolean allowed = loginRateLimiterV1.isAllowed(userId);

  Assertions.assertThat(loginRateLimiterV1.size(userId)).isEqualTo(1);
  Assertions.assertThat(allowed).isTrue();
}
```





##### 문제점 : 동시성

동시에 같은 사용자가 접근하여 데이터를 수정하는 경우가 발생할 수 있습니다.

##### 문제점 : 메모리 누수

다양한 사용자가 한꺼번에 요청을 보내고 메모리 용량을 버티지 못하고 종료될 수 있다.

##### 문제점 : 상태 공유

동일한 사용자가 접근을 하는 경우 상태를 공유하게 되므로 race condition

##### 문제점 : 제어하기 힘든 시간을 기반으로 테스트를 한다

매 테스트 마다 시간이나 설정을 다르게 주지 못한다.







