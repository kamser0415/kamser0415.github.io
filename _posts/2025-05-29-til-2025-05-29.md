---
layout: single
title: TIL) 스트림과 람다에 대해서
categories: TIL
tag: [Today I Learned]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
search: true
sidebar:
    nav: "counts"
typora-root-url: ../
---

스트림을 사용할 때 람다와 오토박싱/언박싱에 대해서 주의할 점에 대해 학습한 내용을 정리하려고 합니다

## Stream 과 오토박싱/언박싱

primitive 타입은 스택 메모리에 직접 할당되며, GC 대상이 되지 않습니다.

반면, 사용자 정의 객체나 오토박싱된 래퍼 객체는 힙에 생성되어 GC의 대상이 됩니다.

GC는 대부분의 객체가 금방 사라진다는 가정에 따라, 메모리를 Young과 Old 영역으로 나누어 관리합니다.

새롭게 생성된 객체가 많아지면 Eden 영역이 포화되어 Minor GC가 트리거되고,

멀티스레드 환경에서는 GC 중 모든 스레드를 정지하는 Stop-The-World가 발생합니다.

특히 Stream API에서 오토박싱이 대량 발생하면, 수많은 래퍼 객체가 힙에 생성되고

이로 인해 GC가 자주 발생하거나, GC 후에도 Used Heap이 높게 유지되어 시스템 응답 성능에 영향을 줄 수 있습니다.



## 람다와 외부 참조

스트림에서 람다가 외부 데이터를 참조하게 되면 람다는 그 값을 **캡쳐**합니다.

**왜 캡쳐를 할까?**

람다는 외부 상태를 변경하지 않는 함수형 프로그래밍 철학을 기반으로 하기 때문입니다.

그래서 동작에 필요한 정보를 내부에 저장한 새 인스턴스를 생성하게 됩니다,

> 외부에 값을 수정하지 않기 위해 내부로 복사하는 거라고 생각하면 편합니다.



외부 참조 대상이 불변이 아닌 경우 람다는 **프로그래밍 철학**을 기반으로 동작합니다.

스트림이 반복될 때마다 새로운 람다 인스턴스가 생성되고 소멸이 됩니다.



이로 인해 오토박싱과 마찬가지로 힙 메모리를 과도하게 생성됩니다.



