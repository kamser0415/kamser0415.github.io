---
layout: single
title: TIL) 동기, 비동기, 리액티브 스트리밍
categories: TIL
tag: [Today I Learned]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
search: true
sidebar:
    nav: "counts"
typora-root-url: ../
---

멘토님에게 질문을 받은 뒤 다시 동기, 비동기, 리액티브 스트리밍에 대해서 정리해보려고 합니다.



비동기 I/O를 사용하는 의미를 생각해봐야합니다.

비동기 I/O는 네트워크, 파일 등 스레드 상태가 대기로 전환되는 작업으로 되지 않고 I/O를 처리하는 방법입니다.

구성 요소는 I/O 작업을 대신 처리해줄 스레드나 스레드 풀이 필요합니다.

별도의 스레드가 필요한 이유는 I/O 호출을 대신하여 현재 스레드가 대기 상태로 가지 않고 기존 로직을 실행할 수 있도록 하기 위해서 입니다.

자바의 경우 스프링 부트나 CommonForkJoinPool 등을 활용하여 멀티 스레드가 요청하는 비동기 작업을 대신 처리해줍니다.



요청된 작업에 대해 FIFO 방식으로 처리하기 위해 큐 자료구조에 실행할 작업들을 저장하게 되는데

큐 자료 구조도 메모리 위에 동작하는 방식이라면 무제한으로 쌓을 수 없습니다.

그래서 멀티 스레드 환경에서 비동기 작업을 요청할 때 비동기 작업을 조율하는 방식을 선택해야합니다.

1. 서킷브레이커
2. 디스크 방식 전환
3. 백프레셔

이런 3가지 방법이 있습니다.

준비큐에 넣다가 더이상 넣지 못하는 경우 이후 호출되는 작업은 모두 실패로 처리하는 서킷브레이커 방식은 서버의 안정화를 위해 사용되며 사용자의 호출이 크게 중요하지 않는 경우에 빠른 거절로 서버 자원을 안정적이게 실행할 수 있습니다.

다만 일정시간에 폭주한 트래픽을 빠르게 처리하여 응답을 빠르게 전달할 수 있지만 사용자는 뒤늦게 호출이 실패한다는 것을 알기에

이때 사용자 호출에 대한 retry도 고려해야합니다.



디스크 방식 전환은 메모리 큐에 저장하면 플래시 특성으로 서버가 다운되면 사라지고, 메모리 위에서 동작하기에 제한된 자원에서 큐 저장을 해야합니다.

그럴때 적절한 방식으로 작업 큐를 디스크에 저장하여 사용자의 요청을 무시하지 않고 모두 처리할 수 있습니다.

이런 방식으로 적절한 것은 인스타의 좋아요와 유사합니다. 이방식을 사용하면 지연 일관성과도 연결된다고 생각합니다.



백프레셔 방식은 비동기 방식에서 중요한 구성요소로 작업 큐에 있는 runnable 최소 단위 메서드를 실행할 때 처리량에 따라 속도를 소비자 측에서 결정하는 방식입니다. 소비자가 pull을 하는 경우에만 작업 큐에 실행할 단위 메서드를 넣습니다.
생산량이 처리량 보다 많을 경우에는 마찬가지로 대기 큐에 넣거나 디스크에 저장하는 방식 또는 서킷 브레이커를 통해 서버를 안정화할 수 있습니다.
